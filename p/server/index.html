<html>

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
</head>

<body>
  <h5>
    <a href="structure.html">整体结构描述</a>
  </h5>
  <h5>Nodejs服务搭建流水账</h5>
  <ul>
    <li><span>sudo 中配置 node,npm 命令</span>
      <pre><code>
  sudo vim /etc/sudoers
  # 找到如下一行,添加后面内容
  # Defaults    secure_path = xxxx:/opt/node-v7.10.0-linux-x64/bin  
  </code></pre></li>
    <li><span>npm 配置为淘宝源</span>
      <pre>
      <code>
      sudo npm config --global set registry='https://registry.npm.taobao.org'
    </code>
    </pre>
    </li>
    <li><span>pm2</span></li>
    <ul>
      <li><a href="../node/pm2.html">安装pm2</a></li>
    </ul>
    <li><span>Express</span>
      <ul>
        <li><a href="../node/express.html">安装Express</a></li>
      </ul>
    </li>
    <li><span>Nginx配置</span>
      <ul>
        <li><a href="../nginx/simple.html">反向代理的配置</a> </li>
      </ul>
    </li>
    <li><span>app.js</span>
      <ul>
        <li>新建app.js,内容如下</li>
        <li>
          <pre>
            <code>            
              var express = require('express');
              var app = express();

              app.get('/', function (req, res) {
                res.send('Hello World!');
              });

              app.listen(3000, function () {
                console.log('Example app listening on port 3000!');
              });
              process.on('SIGINT', function() {
                 db.stop(function(err) {
                   process.exit(err ? 1 : 0);
                 });
              });
          </code>
          </pre>
        </li>
      </ul>
    </li>
    <li><span>pm2 启动</span>
      <ul>
        <li>
          <pre>
          <code>
            pm2 start app.js
          </code>
        </pre>
        </li>
        <li><span><a href="http://pm2.keymetrics.io/docs/usage/startup/">pm2 开机启动</a></span>
          <p>之所以选择这种方式是由于配置文件未来可以自动生成,可以配置更多多个app,以及可以部署配置</p>
          <pre>
          <code>
            $ pm2 ecosystem
          </code>
          会在当前目录生成ecosystem.config.js,我的内容如下
          <code>
            module.exports = {
              /**
               * Application configuration section
               * http://pm2.keymetrics.io/docs/usage/application-declaration/
               */
              apps: [{
                "name": "dream_be",
                "script": "/home/xxx/webroot/app.js",
                "instances": 0,
                "watch": true,
                "exec_mode": "cluster",
                "cwd": "/home/xxx",
                "env": {
                  "NODE_ENV": "development",
                },
                "env_production": {
                  "NODE_ENV": "production"
                }
              }]
            };            
          </code>
          启动,保存进程信息.
          <code>
            pm2 start /home/xxx/ecosystem.config.js
            pm2 save
            pm2 startup systemd -u xxx
            # 会输出一条命令,复制执行即可 例如: sudo env PATH=$PATH:/opt/node-v6.10.3-linux-x64/bin pm2 startup systemd -u xxx --hp /home/xxx
          </code>
        </pre>
        </li>
      </ul>
    </li>
    <li><span>Nginx 重启</span>
      <ul>
        <li>
          <pre>
          <code>
            sudo systemctl stop nginx
            sudo systemctl start nginx
          </code>
        </pre>
        </li>
      </ul>
    </li>
    <li><span>测试</span>
      <ul>
        <li>
          <pre>
          <code>
            curl 192.168.2.82 # 这是我自己的虚拟机地址也可以浏览器访问

            < Hello World!
          </code>
        </pre>
        </li>
      </ul>
    </li>
  </ul>
  <p>现在考虑的是Express路由文件如何管理.期望达到的效果有.
    <ul>
      <li><span>1. url直接映射为文件,方便管理</span></li>
      <li><span>2. 最好能够提供热重载,无需重启整个服务器,既能针对单个handle更新</span></li>
    </ul>
  </p>
  <p>
    参考了<a href="http://fex.baidu.com/blog/2015/05/nodejs-hot-swapping/">热更</a>的思路和<a href="http://blog.fantasy.codes/node.js/2016/10/08/express-route-loader/">自动路由加载</a>可以结合一下,完成一个路由文件加载机制,暴露get,reload,update函数.app运行时通过get来获取对应的路由处理handle,路由文件的更新不是通过文件的覆盖,而是通过update函数更新路由文件.更新完之后通过reload来重新加载最新的路由文件,同时对处理中的请求继续处理.同时在服务启动的时候一次性加载所有handle
  </p>
  <p>实际运行的时候服务器端代码是否需要编译?如果需要选择什么编译框架比较好?</p>
  <p>现在思路有点乱了.....</p>
  <p>回到正轨,首先需要把程序跑起来,然后再做各个目录的规划</p>
  <p>
    <ul>
      <li>首先分离客户端代码和服务器端代码</li>
      <li>Ningx能够动静分离配置</li>
    </ul>
  </p>
  <p>重新规划服务器上目录结构</p>
  <p>
    <pre>
    <code>
    /home/xx/webroot/
      server/ 服务端目录
        handle/ 提供rest接口
        libs/ 库文件
        middle/ connect中的middleware
        utils/ 工具文件
      client/ 客户端目录
        static/ 纯静态文件
          img/
          js/
          css/
        tpl/ 预计是页面的template文件 这个文件暂时没有考虑好,主要是暂时不清楚如何组装页面
    </code>
  </pre>
  </p>
  <p>
    接下来得计划是先处理服务器端的功能
  </p>
  <p>
    Https的配置,在阿里云上还是比较简单的,就不重复了,自行百度. 顺便给个链接吧<a href="https://yq.aliyun.com/articles/65199">证书如何选择</a>
  </p>
  <p>配置完之后注意Nginx需要的是 先停止然后启动 stop start 不是 reload</p>
  <p>现在我的主页已经能够https访问了,当然没有放弃http,Nginx做一个301跳转既可
    <pre>
    <code>
      server {
          listen 80;
          server_name localhost;
          rewrite ^(.*) https://$host$1 permanent;
      }
      # systemctl stop nginx
      # systemctl start nginx
    </code>
  </pre>
  </p>
  <p>
    现在遇到个问题: 随着对系统的配置内容越来越多,再发生变更后的事故风险会增加,比如Nginx变更,如果出现问题,会导致整站不可用,而且没有历史版本的记录.而且无法恢复. 所以最好能有版本控制.并且所有配置文件最好都是通过工具跟新上去,而不是手动修改. 有时间再折腾吧.
  </p>
  <p>
    然后就是动静分离,纯静态文件直接走Nginx了,动态文件就走node,这里的Nginx配置借鉴了公司项目中的处理.通过 try_files 来处理,优先寻找静态文件,如果没有的时候请求node. 这样在Node中可以结合模板技术做服务器端组装.配置文件在<a href="https://github.com/chzhm159/dream/tree/master/nginx">Nginx配置文件</a>
  </p>
  <p>
    继续往前拱,nodejs中如何动态加载handle?决定还是公司自己开发的加载方案,主要特性有:动态路由加载,参数解析,middlewware兼容,初次加载,然后缓存.再借鉴之前一个项目的处理方式,文件名中带后缀的方式来区分GET,POST等请求方式.之后会放在git主页中
  </p>
  <p>
    <a href="https://www.loggly.com/blog/three-node-js-libraries-which-make-sophisticated-logging-simpler/">nodejs 日志模块</a>
  </p>
  <p>
    经过一番折腾,微信公众号已经和阿里云的服务器对接了,另外并没有先实现handle的动态加载,而是先用Express默认的路由机制,本身就一个接口
  </p>
  <p>接下来配置服务器上的数据库,其实在数据库的选择上还是比较纠结的,主要纠结在mongodb和Elastic之间,mongodb之间,但水平不够,无法区分两者对于我的影响,但是考虑到这个项目的前期主要是搜索,所以还是先用ES,大不了后期再换数据库也容易
    <ul>
      <li><span>安装java</span></li>
      <li>
        <span><a href="http://www.oracle.com/technetwork/java/javase/downloads/server-jre8-downloads-2133154.html">server jre下载</a></span>
      </li>
      <li>
        <p>配置环境变量</p>
        <p>将下载的server-jre-8u131-linux-x64.tar文件放在了/opt目录下</p>
        <p>需要补充一篇几个jvm版本的区别</p>
        <p>解压</p>
        <pre>
        <code>
         # tar -xvf server-jre-8u131-linux-x64.tar.gz
        </code>
      </pre>
        <span>然后配置环境变量</span> 编辑文件 /etc/profile 并在最后追加如下内容
        <pre>
        <code>
          JAVA_HOME=/opt/jdk1.8.0_131/bin
          export JAVA_HOME
          PATH=xxx:/opt/jdk1.8.0_131/bin
        </code>
      </pre> 保存退出后,使环境变量生效
        <pre>
        <code>
          source /etc/profile
          # 两条测试命令
          javac -version
          java -version
        </code>
      </pre>
      </li>
      <li>
        <p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/_installation.html">Elastic安装</a></p>
        <p>最好采用rpm安装</p>
        <p>安装完之后就是配置我的配置部分内容 </br>
          <pre>
            <code>
              1. 修改ES中java目录
                sudo vim /etc/sysconfig/elasticsearch
                JAVA_HOME=/opt/jdk1.8.0_144
              2. 修改ES基本配置
                sudo vim /etc/elasticsearch/elasticsearch.yml
                  cluster.name: dream
                  node.name: dream-data-1
                  path.data: /home/czm/data/db
                  path.logs: /var/log/elasticsearch
                  network.host: 127.0.0.1
                  http.cors.enabled: true
                  http.cors.allow-origin: "*"
              3. 修改JVM配置
                sudo vim /etc/elasticsearch/jvm.options
                  -Xms1g
                  -Xmx1g
              </code>
            </pre>
        </p>
        <p>
          <pre>
            <code>
              sudo systemctl daemon-reload
              sudo systemctl enable elasticsearch
              sudo systemctl start elasticsearch
            </code>
          </pre>
        </p>
        <p>
          期间遇到两个问题
          <ul>
            <li>
              java 环境变量是配置在了 /etc/profile文件中了,但是不知道为什么,es在启动的时候报找不到java
              <p>解决办法我是直接 /etc/sysconfig/elasticsearch 中加入了java的安装路径,</p>
            </li>
            <li>
              以为ES是rpm安装,安装过后是新建了一个"elasticsearch"的用户,导致我修改了path.data之后,启动失败
              <p>解决办法比较笨:</br>
                <pre>
                <code>
                  setfacl -m u:elasticsearch:x /home/czm
                  setfacl -m u:elasticsearch:x /home/czm/data
                  setfacl -m u:elasticsearch:rwx /home/czm/data/db
                </code>
              </pre>
              </p>
            </li>
          </ul>
        </p>
        <p>
          启动后测试是否正确
          <pre>
            <code>
              curl localhost:9200 
              {
                "name" : "dream-data-1",
                "cluster_name" : "xxxx",
                "cluster_uuid" : "xxx",
                "version" : {
                  "number" : "5.4.2",
                  "build_hash" : "xxxx",
                  "build_date" : "2017-06-xxxx:29:28.122Z",
                  "build_snapshot" : false,
                  "lucene_version" : "6.5.1"
                },
                "tagline" : "You Know, for Search"
              }
            </code>
          </pre>
        </p>
        <p>
          默认的log貌似是/var/log/elasticsearch目录
        </p>
      </li>
    </ul>
  </p>
  <p>
    当时为了先把环境搭建起来,nginx是通过rmp安装的,随后发现这种方式后续安装module不方便,所以卸载后选择编译安装 </br>
    <pre><code>
    Note : These steps to Remove / Uninstall Nginx has been tested on CentOS, RHEL and Oracle Linux platform and was running under root privilege.
    

    0. yum install gcc-c++


    1. Stop Nginx service and remove Nginx auto start script :
      [root@rhel7 ~]# sudo systemctl stop nginx.service
      [root@rhel7 ~]# sudo systemctl disable nginx.service


    2. Remove Nginx user and it related directory :
      [root@rhel7 ~]# sudo userdel -r nginx


    3. Delete and related Nginx installation directory :
      [root@rhel7 ~]# sudo rm -rf /etc/nginx
      [root@rhel7 ~]# sudo rm -rf /var/log/nginx
      [root@rhel7 ~]# sudo rm -rf /var/cache/nginx/


    4. Remove the created nginx.service script under systemd :
      [root@rhel7 ~]# sudo rm -rf /usr/lib/systemd/system/nginx.service

    </code></pre> 源码编译安装 </br>
    官网地址:<a href="https://www.nginx.com/resources/admin-guide/installing-nginx-open-source/">https://www.nginx.com/resources/admin-guide/installing-nginx-open-source/</a> </br>
    我是用在外网,稳定优先所以选择stable版,安装过程参考官网即可
  </p>
  <p>
    <p>源码编译安装最新版 <a href="https://redis.io/topics/quickstart">https://redis.io/topics/quickstart</a>
      </br>
      <pre>
          <code>
          wget 'http://download.redis.io/releases/redis-4.0.1.tar.gz'
          tar xzf redis-4.0.1.tar.gz
          cd redis-4.0.1
          make distclean
          make
          make install

          sudo mkdir /etc/redis
          sudo mkdir /var/redis
          sudo cp utils/redis_init_script /etc/init.d/redis_6379
          sudo vi /etc/init.d/redis_6379
          sudo cp redis.conf /etc/redis/6379.conf
          sudo mkdir /var/redis/6379
          </code>
        </pre>
      <p>
        <p>Edit the configuration file, making sure to perform the following changes:</p>
        <p>Set 'daemonize' to yes (by default it is set to no).</p>
        <p>Set the 'pidfile' to /var/run/redis_6379.pid (modify the port if needed).</p>
        <p>Change the port accordingly. In our example it is not needed as the default port is already 6379.</p>
        <p>Set your preferred loglevel.</p>
        <p>Set the 'logfile' to /var/log/redis_6379.log</p>
        <p>Set the 'dir' to /var/redis/6379 (very important step!)</p>
        <p>Set 'supervised' systemd (by default it is set to no).</p>
        <p>因为我的系统是Centos7,使用systemd,所以到这就不按照官网的配置执行而是直接执行以下命令,虽然/etc/systemd/system/下并没有对应的配置文件,但是是可以正常启动的(找了一下原因没找到,但是测试正常就没管)</p>
      </p>
      然后启动服务
      <pre>
        <code>
          systemctl daemon-reload
          sudo systemctl enable redis_6379
          sudo systemctl start redis_6379;systemctl status redis_6379
          redis-cli ping
          > PONG # 正常
        </code>
      </pre>
    </p>
  </p>
</body>

</html>